                       <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>563(sed) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">Name </A></H2>
bgexec - Run Unix commands in the background 
while handling Tk events.  
<H2><A NAME="sect1" HREF="#toc1">Synopsis </A></H2>
<B>bgexec <I>varName </I></B> ?<I>option value </I>?... <I>command 
</I> ?<I>arg </I>?...  
<H2><A NAME="sect2" HREF="#toc2">Description </A></H2>
<P>
The <B>bgexec </B> command executes Unix commands in the 
background, allowing Tk to handle events.  A global Tcl variable <I>varName 
</I> is set when the command has completed.  
<H2><A NAME="sect3" HREF="#toc3">Introduction </A></H2>
Tcl's <B>exec </B> command 
is very useful for gathering information from the Unix system.  It runs 
a Unix command and returns the output of the command as its result.  This 
works well for Tcl-only applications. But in Tk applications, a problem 
occurs when a Unix command takes time to process.  For example, let's say 
we want the get the disk usage of a directory.  We'll use the Unix command 
<I>du </I> to get the summary.  <BR>
<P>
<CODE> set out [exec du -s $dir] <BR>
 puts "Disk usage for 
$dir is $out" <BR>
 </CODE><P>While <I>du </I> is running, scrollbars won't respond.  None of 
the Tk widgets will be redrawn properly.  The <B>send </B> command won't work. And 
the worst part is that the application appears hung up or dead. The problem 
is that while the application is waiting for <I>du </I> to finish, Tk is not 
handling X events. <P>
The <B>bgexec </B> command performs the same functions as <B>exec 
</B>, but also allows Tk to handle events.  You can execute a long-running Unix 
command and the Tk widgets will behave normally.  When the command finishes, 
its output and the exit status are written to Tcl variables.  This makes 
it easy to monitor and save the output of a command.  
<H2><A NAME="sect4" HREF="#toc4">Example </A></H2>
This is the 
disk usage example again, this time using <B>bgexec </B>. The Unix command syntax 
is exactly the same as the previous example, when we used <B>exec </B>.  <BR>
<P>
<CODE> global 
myStatus myOutput <BR>
 bgexec myStatus -output myOutput du -s $dir <BR>
 puts "Disk 
usage for $dir is $myOutput" <BR>
 </CODE><P>Two global variables, <I>myStatus </I> and <I>myOutput 
</I>, will be set by <B>bgexec </B> when the <I>du </I> command has completed. <I>MyStatus </I> 
will contain the command's exit status.  <I>MyOutput </I>, specified by the <B>-output 
</B> option, will store the output of the command. <P>
You can also terminate the 
command by setting the variable <I>myStatus </I>. If <I>myStatus </I> is set before <I>du 
</I> has completed, the process is killed by sending a configurable Unix signal 
(by default it's SIGKILL).  It makes no difference what <I>myStatus </I> is set 
to.  <BR>
<P>
<CODE> set myStatus {} <BR>
 </CODE><P>There are other <B>bgexec </B> options to collect different 
types of  information.  <BR>
<P>
<CODE> global myStatus myOutput myErrs <BR>
 bgexec myStatus 
-output myOutput -error myErrs du -s $dir <BR>
 </CODE><P>The <B>-error </B> option is similar to 
<B>-output </B>.  It sets a global variable when the command completes.  The variable 
will contain any data written to stderr by the command. <P>
The <B>-output </B> and 
<B>-error </B> variables are written to only after the command completes.  If the 
command takes a long time, you may want to receive its partial output. 
 You can gather data as it becomes available using the <B>-onoutput </B> option. 
 It specifies a Tcl command prefix.  Whenever new data is available, this 
command is executed, with the data appended as an argument to the command. 
 <BR>
<P>
<CODE> proc GetInfo { data } { <BR>
     puts $data <BR>
 } <BR>
 bgexec myStatus -onoutput 
GetInfo du -s $dir <BR>
 </CODE><P>When output is available, the procedure <I>GetInfo </I> is 
called. The <B>nerror </B> option performs a similar function for the stderr data 
stream. <P>
Like <B>exec </B>, <B>bgexec </B> returns an error if the exit code of the Unix 
command is not zero.  If you think you may get a non-zero exit code, you 
might want to invoke <B>bgexec </B> from within a <B>catch </B>.  <BR>
<P>
<CODE> catch { bgexec myStatus 
-output myOutput du -s $dir } <BR>
 </CODE><P>By default, <B>bgexec </B> will wait for the command 
to finish. But you can detach the command by adding an ampersand (&amp;) to 
the end of the command line.  <BR>
<P>
<CODE> global myStatus myOutput <BR>
 bgexec myStatus 
-output myOutput du -s $dir &amp; <BR>
 </CODE><P><B>Bgexec </B> will return immediately and its result 
will be a list of the spawned process ids.  If at some point, you need 
to wait for the command to finish, you can use <B>tkwait </B>.  When the command 
finishes, the variable <I>myStatus </I> will be written to, breaking the <B>tkwait 
</B> loop.  <BR>
<P>
<CODE> global myStatus myOutput <BR>
 bgexec myStatus -output myOutput du -s 
$dir &amp; <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;... <BR>
 tkwait variable myStatus <BR>
 </CODE><P> 
<H2><A NAME="sect5" HREF="#toc5">Syntax </A></H2>
The <B>bgexec </B> command takes the 
following form:  <P>
<B><tt> </tt>&nbsp;<tt> </tt>&nbsp;bgexec <I>varName </I></B> ?<I>option value </I>?... <I>command </I> ?<I>arg </I>?...  <P>
<I>VarName 
</I> is the name of a global variable which is set when the designated Unix 
command has finished executing.  The exit status of the command will be 
stored in <I>varName </I>.  The exit status is a list of a status token, the process-id 
of the command, the exit code, and a status message.  You can also prematurely 
terminate the command by setting <I>varName </I>.  The command will be sent a 
signal to terminate it (by default the signal is a SIGKILL; see the <B>-killsignal 
</B> option). <P>
<I>Command </I> is the name of the Unix command to be executed and <I>args 
</I> are any extra arguments for <I>command </I>.  <I>Command </I> and <I>args </I> may be in any 
form accepted by <B>exec </B>. (See the <B>exec </B> manual for further information.) 
 If the last argument is an ampersand (&amp;), the command will be run detached, 
and <B>bgexec </B> will return immediately.  <I>VarName </I> will still be set with the 
return status when <I>command </I> completes.  
<H2><A NAME="sect6" HREF="#toc6">Options </A></H2>
<I>Option </I> is the switch name, 
always beginning with a dash (-). <I>Value </I> is the value of the option.  Option-value 
pairs are terminated either by the Unix command name, or double dashes 
(--). The following options are available for <B>bgexec </B>: 
<DL>

<DT><B>-error <I>varName </I></B>   </DT>
<DD> 
<BR>
Specifies that a global variable <I>varName </I> is to be set with the contents 
of stderr after the command has completed.  </DD>

<DT><B>-keepnewline <I>boolean </I></B>  </DT>
<DD>Specifies 
that a trailing newline should be retained in the  output. If <I>boolean </I> 
is true, the trailing newline is truncated from the output of the <B>-onoutput 
</B> and <B>-output </B> variables.   The default value is <I>true </I>. </DD>

<DT><B>-killsignal <I>signal 
</I></B>  </DT>
<DD>Specifies the signal to be sent to the Unix command when  terminating. 
<I>Signal </I> can either be a number (typically 1-32) or a mnemonic (e.g. SIGINT). 
If <I>signal </I> is the empty string,  then no signal is sent.  The default signal 
is <I>9 </I> (SIGKILL). </DD>

<DT><B>-lasterror <I>varName </I></B>  </DT>
<DD>Specifies a variable <I>varName </I> that 
is updated whenever data becomes available from standard error of the 
Unix command. <I>VarName </I> is a global variable. Unlike the <B>-error </B> option, data 
is available as soon as it arrives. </DD>

<DT><B>-lastoutput <I>varName </I></B>   </DT>
<DD>Specifies a variable 
<I>varName </I> that is updated whenever data becomes available from standard 
output of the Unix command. <I>VarName </I> is a global variable. Unlike the <B>-output 
</B> option, data is available as soon as it arrives. </DD>

<DT><B>-output <I>varName </I></B>  </DT>
<DD> <BR>
Specifies 
that a global variable <I>varName </I> is to be set with the output of the command, 
after the commmand has completed.  If this option  is not set, no output 
will be accumulated. </DD>

<DT><B>-onerror <I>command </I></B>  </DT>
<DD>Specifies the start of a Tcl command 
that will be executed whenever new data is available from standard error. 
The data is appended to the command as an extra argument before it is 
executed. </DD>

<DT><B>-onoutput <I>command </I></B>   </DT>
<DD>Specifies the start of a Tcl command that 
will be executed whenever new data is available from standard output. The 
data is appended to the command as an extra argument before it is executed. 
</DD>

<DT><B>-update <I>varName </I></B>   </DT>
<DD>Deprecated. This option is replaced by <B>-onerror </B>. </DD>

<DT><B>-- </B>  </DT>
<DD>This 
marks the end of the options.  The following argument will be considered 
the name of a Unix command even if it starts with  a dash (<B>- </B>). </DD>
</DL>
 
<H2><A NAME="sect7" HREF="#toc7">Preemption 
</A></H2>
Because Tk events are handled while a Unix command is running, it's possible 
for an application to preempt itself with further user-interactions.  Let's 
say your application has a button, that when pressed runs the disk usage 
example.  While the <I>du </I> command is already running, the user may press 
the button again.  The second <B>bgexec </B> command will preempt the first.  This 
means that the first command can not finish until the second command has 
completed. <P>
Care must be taken to prevent an application from preempting 
itself, by blocking further user-interactions (such as button clicks).  
The BLT <B>busy </B> command is very useful in these situations, temporarily 
preventing user interaction. See the <B>busy </B> manual for details.  
<H2><A NAME="sect8" HREF="#toc8">Differences 
with Fileevent </A></H2>
Some of the functionality of <B>bgexec </B> is now be provided 
in Tk 4.0 with the <B>fileevent </B> command.  The steps for running a command 
in the background are: <P>
Execute the Unix command with the <B>open </B> command 
(using the "|" syntax) and save the file handle.  <BR>
<P>
<CODE> global fileId  <BR>
 set fileId 
[open "|du -s $dir" r] <BR>
 </CODE><P>Next register a Tcl code snippet with <B>fileevent 
</B> to be run whenever output is available on the file handle.  The code snippet 
will read from the file handle and save the output in a variable.  <BR>
<P>
<CODE> fileevent 
fileId readable {  <BR>
     if { [gets $fileId line] &lt; 0 } { <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;close $fileId 
<BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;set output $temp <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;unset fileId temp <BR>
     } else { <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;append temp $line 
<BR>
     } <BR>
 } <BR>
 </CODE><P>While this works with the above example, but there are some 
important differences. <P>
The biggest advantage of <B>bgexec </B> is that it requires 
no additional Tcl code to run a Unix command.  It's simpler, and therefore 
there's less chance of errors being introduced. <P>
<B>Bgexec </B> also handles things 
that <B>fileevent </B> can not.  For example, you can't get back the exit status 
of the command.  In the code above, we're assuming that the command has 
completed once stdout is closed.  The problem is that some commands, like 
<I>compress </I>, reopen stdout, which fool <B>fileevent </B>.  We're also assuming that 
the Unix command will write its output line-by-line.  Running another command, 
your application may block in the <B>gets </B> command, reading a partial line. 
 Conversely, <B>bgexec </B> handles non-blocking I/O tranparently for you.  Finally, 
since data collection is handled in C code, <B>bgexec </B> is faster, getting 
you back to the Tk event loop more quickly.  
<H2><A NAME="sect9" HREF="#toc9">See Also </A></H2>
busy, exec, tkwait 
 
<H2><A NAME="sect10" HREF="#toc10">Keywords </A></H2>
exec, background, busy <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Introduction</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Example</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Syntax</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Options</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Preemption</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Differences with Fileevent</A></LI>
<LI><A NAME="toc9" HREF="#sect9">See Also</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Keywords</A></LI>
</UL>
</BODY></HTML>
